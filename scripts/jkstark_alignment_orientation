#!/usr/bin/env python
# -*- coding: utf-8; fill-column: 120 -*-
#
# This file is part of JK Python extensions
# Copyright (C) 2009 Frank Filsinger
# Copyright (C) 2009 Jochen Küpper <software@jochen-kuepper.de>
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# If you use this programm for scientific work, you must correctly reference it; see LICENSE file for details.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program. If not, see
# <http://www.gnu.org/licenses/>.
#
# some SGE commands for batch usage convenience
#$ -cwd
#$ -e $JOB_NAME.sge
#$ -o $JOB_NAME.sge
#$ -S $HOME/.python/bin/python
#$ -V
from __future__ import division

"""Calculate alignment and orientation for ensemble of molecules (only linear pseudo asymmetric right now)"""

__author__ = "Jens H Nielsen, Frank Filsinger and Jochen Küpper"

import getopt, sys
import math
import numpy

import jkext.const as const
import jkext.convert as convert
import jkext.hdf5 as hdf5
import jkstark.molecule as molecule
import jkstark.starkeffect as starkeffect
from jkstark.population  import create_population, read_population
from jkext.state import State
import matplotlib.pyplot as plt
import jkstark.convert
from jkstark.wavefunction import calcwaveparam
import tables

def usage():
    # ToDo implement a useful usage description
    print "See script for details"


def main(args):
    try:
        opts, args = getopt.getopt(args[1:], "hJ:m:p:T:", ["help",
                                                           "dcfield=","acfield=", "Jmax=", "mu=", "nssw=", "nssw-type=",
                                                           "population=", "temperature=", "save="])
    except getopt.GetoptError, err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    # default values
    thermal = False
    nonthermal = False
    dcfieldplot = 0. # kV/cm
    acfieldplot = 0.
    temperature = 1. # K
    Jmax = 6
    nsswtype = None
    nssw = None
    saving = False
    # scan commandline
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("--dcfield"):
            dcfieldplot = convert.kV_cm2V_m(float(a))
        elif o in ("--acfield"):
            acfieldplot = float(a)
        elif o in ("-J", "--Jmax"):
            Jmax = int(a)
        elif o in ("-m", "--mu",):
            mu = convert.D2Cm(float(a))
        elif o in ("--nssw",):
            nssw = map(int, a.split(":"))
        elif o in ("--nssw-type",):
            if a == "None":
                nsswtype = None
            elif a in ("Ka", "K-1"):
                nsswtype = "Ka"
            else:
                assert False, "unknown NSSW-type %s" % (a, )
        elif o in ("-p", "--population"):
            nonthermal = True
            pop = a
        elif o in ("-T", "--temperature"):
            thermal = True
            temperature = float(a)
        elif o in ("--save"):
            saving = True
            storage = a
        else:
            assert False, "unhandled commandline option"

    if thermal == nonthermal:
        assert False, "commandline parsing resulted in thermal == nonthermal; stopping"

    for name in args:
        # create Molecule object and specify storage file
        param = starkeffect.CalculationParameter
        mol = molecule.Molecule(storage=name)
        mol.getparam(param)
        # create population
        # handle the two possible cases for the population (nonthermal != thermal is assured above)
        if thermal == True:
            population = create_population(mol, temperature, Jmax, nsswtype, nssw)
        else:
            population = read_population(pop)
        # calculate orientation cosine -- loop over states
        weight = 0
        i = 0
        for p in population:
                state = p[0]
                w = p[1]
                if w>1e-5:
                    dcfields = mol.dcfields(state,acfieldplot)
                    cos2 = numpy.zeros_like(dcfields)
                    cos = numpy.zeros_like(dcfields)
                    up_total = numpy.zeros_like(dcfields)
                    h = 0
                    for dcfield in dcfields:
                        cos[h],cos2[h],up_total[h],psi,thetas = calcwaveparam(state,dcfield,acfieldplot,mol)
                        h = h+1
                    h = 0    
                    if i == 0:
                        cos2s_dc = w * cos2
                        coss_dc = w * cos
                        up_totals_dc = w * up_total
                    else:
                        cos2s_dc += w * cos2
                        coss_dc += w * cos
                        up_totals_dc += w * up_total
                    weight += w
                    i = i + 1
        cos2s_dc /= weight
        coss_dc /= weight
        up_totals_dc /= weight
        plt.figure(1)
        plt.plot(convert.V_m2kV_cm(dcfields), cos2s_dc)
        plt.xlabel(r'$DC field \quad \frac{kV}{cm}$')
        plt.ylabel(r'$\langle cos^2 \theta \rangle$')
        plt.figure(2)
        plt.plot(convert.V_m2kV_cm(dcfields), coss_dc)
        plt.xlabel(r'$DC field \quad \frac{kV}{cm}$')
        plt.ylabel(r'$\langle cos \theta \rangle$')
        plt.figure(3)
        plt.plot(convert.V_m2kV_cm(dcfields), up_totals_dc)
        plt.xlabel(r'$DC field \quad \frac{kV}{cm}$')
        plt.ylabel(r'$\frac{UP}{Total}$')
        if thermal == True:
            plt.title(r'T = %f K'  %(temperature))
        else:
            plt.title(r'Non thermal')
        i = 0
        weight = 0
        for p in population:
                state = p[0]
                w = p[1]
                if w>1e-5:
                    acfields = mol.acfields(state)
                    cos2 = numpy.zeros_like(acfields)
                    cos = numpy.zeros_like(acfields)
                    up_total = numpy.zeros_like(acfields)
                    h = 0
                    for acfield in acfields:
                        cos[h],cos2[h],up_total[h],psi,thetas = calcwaveparam(state,dcfieldplot,acfield,mol)
                        h = h+1
                    h = 0    
                    if i == 0:
                        cos2s_ac = w * cos2
                        coss_ac = w * cos
                        up_totals_ac = w * up_total
                    else:
                        cos2s_ac += w * cos2
                        coss_ac += w * cos
                        up_totals_ac += w * up_total
                    weight += w
                    i = i + 1
        cos2s_ac /= weight
        coss_ac /= weight
        up_totals_ac /= weight
        plt.figure(4)
        plt.plot(jkstark.convert.V_m2w_cm2(acfields), cos2s_ac)
        plt.xlabel(r'$Laser Intensity \quad \frac{W}{cm^2}$')
        plt.ylabel(r'$\langle cos^2 \theta \rangle$')
        plt.figure(5)
        plt.plot(jkstark.convert.V_m2w_cm2(acfields), coss_ac)
        plt.xlabel(r'$Laser Intensity \quad \frac{W}{cm^2}$')
        plt.ylabel(r'$\langle cos \theta \rangle$')
        plt.figure(6)
        plt.plot(jkstark.convert.V_m2w_cm2(acfields), up_totals_ac)
        plt.xlabel(r'$Laser Intensity \quad \frac{W}{cm^2}$')
        plt.ylabel(r'$\frac{UP}{Total}$')
        if thermal == True:
            plt.title(r'T = %f K'  %(temperature))
        else:
            plt.title(r'Non thermal')
        if saving == True:
            name = 'align_ori_data'
            file = tables.openFile(storage, mode='a', title=name)
            hdf5.writeVLArray(file,'/','acfields',acfields)
            hdf5.writeVLArray(file,'/','intensities',jkstark.convert.V_m2w_cm2(acfields))
            hdf5.writeVLArray(file,'/','dcfields',dcfields)
            hdf5.writeVLArray(file,'/','up_total_ac',up_totals_ac)
            hdf5.writeVLArray(file,'/','up_total_dc',up_totals_dc)
            hdf5.writeVLArray(file,'/','cos_ac',coss_ac)
            hdf5.writeVLArray(file,'/','cos_dc',coss_dc)
            hdf5.writeVLArray(file,'/','cos2_ac',cos2s_ac)
            hdf5.writeVLArray(file,'/','cos2_dc',cos2s_dc)
        plt.show()
if __name__ == "__main__":
    main(sys.argv)

