C     Some compiler options for numpy.distutils
C
CF77FLAGS(gnu) = -ffixed-line-length-72 -Wn0-line-truncation
CF77FLAGS(gnu95) = -ffixed-line-length-72 -Wno-line-truncation
C
C
c     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c                              W I G N E R F F T
c     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c     FORTRAN ROUTINES FOR SPHERICAL HARMONIC AND WIGNER d-FUNCTION
c     CALCULATIONS BY FFT
c
c     Copyright (C) 2006 Stefano Trapani
c     Copyright (C) 2006 Jorge Navaza
c
c     e-mails: stefano.trapani@cbs.cnrs.fr
c              jorge.navaza@ibs.fr
c
c     This program is free software; you can redistribute it and/or
c     modify it under the terms of the GNU General Public License as
c     published by the Free Software Foundation; either version 2 of the
c     License, or (at your option) any later version.
c
c     This program is distributed in the hope that it will be useful,
c     but WITHOUT ANY WARRANTY; without even the implied warranty of
c     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
c     General Public License for more details.
c
c     You should have received a copy of the GNU General Public License
c     along with this program; if not, write to the Free Software
c     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
c     02110-1301, USA. You can also find the GPL on the GNU web site:
c     http://www.gnu.org/copyleft/gpl.html.
c
c     In addition, we kindly ask you to acknowledge WIGNERFFT and its
c     authors in any program or publication in which you use
c     WIGNERFFT. (You are not required to do so; it is up to your common
c     sense to decide whether you want to comply with this request or
c     not.) For general publications, we suggest referencing:
c
c     Trapani, S. & Navaza, J. "Calculation of spherical harmonics and
c     Wigner d functions by FFT.  Applications to fast rotational
c     matching in molecular replacement and implementation into AMoRe"
c     Acta Cryst. (2006). A62, 262­269
c
c     To make this software work, it must be linked to the FFTW library
c     (version 3.0.1 or higher), which is available under the GNU
c     General Public License. FFTW is Copyright © 2003, 2006 Matteo
c     Frigo, Copyright © 2003, 2006 Massachusetts Institute of
c     Technology. The FFTW library is not included in the WIGNERFFT
c     distribution. The FFTW library can be obtained from:
c     http://www.fftw.org.
c     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


c     NOTICE:
c
c     * Definition of spherical harmonics (SH) and Wigner functions as
c     in: Navaza, J. (2001). Crystallography of Biological
c     Macromolecules, International Tables for Crystallography, Vol. F,
c     edited by M. G.  Rossmann & E. Arnold, pp. 269--274. International
c     Union of Crystallography.
c
c     * To make this software work, it must be linked to the
c     "libfftw3.a" (single precision) and/or "libfftw3f.a" (double
c     precision) FFTW libraries (version 3.0.1 or higher). Also, the
c     "fftw3.f" file must be reachable at complilation time.
c     "libfftw3.a" and "libfftw3f.a" can be generated by compiling the
c     source FFTW code with the '-enable-fortran' option. For the
c     libfftw3.a file the '--enable-single' option must also be used.


c     DESCRIPTION:

c     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c     subroutine dp2l(l,dlmm)
c     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c
c     Calculates the Wigner's d(pi/2)-matrix (delta matrix) of degree l
c     using recursive formulas and double-precision arithmetics.
c     Only the bottom half of the matrix (m1>=0) is output.
c
c
c     TYPE              USE  NAME DIMENSIONS  DESCRIPTION
c     integer           In     l              degree of the delta-matrix
c     doubleprecision   Out dlmm (0:l,-l:l)   delta-matrix(m1,m2)


c     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c     subroutine dp2lln(lsup,l,iex,dmm,first)
c     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c
c     Calculates the Wigner's d(pi/2)-matrix (delta matrix) of degree l.
c     Calculation is performed using double-precision logarithmic
c     recursive formulas.
c     Only the bottom half of the matrix (m1>=0) is output.

c     TYPE              USE  NAME DIMENSIONS  DESCRIPTION
c     integer           In   lsup             the logarithm of factorials up to log(lsup!) (for local use) will be calculated and saved for successive calls
c     integer           In      l             degree of the delta-matrix to be calculated. It must be <=lsup.
c     integer           Out   iex (0:l,-l:l)  neperian exponents of the delta-matrix elements
c     doubleprecision   Out   dmm (0:l,-l:l)  neperian mantissas of the delta-matrix elements
c     logical           I/O first             .true.  -> the logarithmic factorials are calculated
c                                             .false. -> uses logarithmic factorials saved during a previous call


c     +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c     subroutine slmfft(lmax, npa, l, m2, m1min, m1max, sh, hshift ,dp2, ktest, kdp2, b, dlm, cex, fftrig, first)
c     +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c     subroutine dlmfft(lmax, npa, l, m2, m1min, m1max, sh, hshift ,dp2, ktest, kdp2, b, dlm, cex, fftrig, first)
c     +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c
c     Calculate d-functions or SH colatitudinal components in single and double precision (slmfft and dlmfft respectively).
c     The output is one d-matrix column (or part of the column) for each beta value sampled between 0 and Pi
c     ( d^l_m1_m2(beta_i), l and m2 fixed, m1min <= m1 <= m1max, 0<= i <= npa)
c          .
c
c     TYPE             USE   NAME DIMENSIONS  DESCRIPTION
c
c     integer          In    lmax                used for dimensioning
c     integer          In     npa                No. of angular samples in the range (0,pi]. It must be even (FFTW requirement).
c                                                Faster computations are achieved if npa can be factorized into primes smaller or equal to 11.
c                                                (In the documentation of FFTW, npa corresponds to N, the logical size of a real-even or real-odd FFT).
c     integer          In       l                the degree of the Wigner/SH functions to be calculated.
c                                                (l <= lmax)
c     integer          In      m2                the index of the d-matrix column to be calculated.
c                                                Set m2=0 for SH calculation.
c     integer          In   m1min                See below
c     integer          In   m1max                Only matrix elements with m1min <= m1 <= m1max will
c                                                be calculated.
c     logical          In      sh                if .false. -> calculate d-matrices
c                                                if .true.  -> calculate SHs (effective only if m2=0)
c     logical          In  hshift                if .false. -> the output will consist of npa+1 equispaced
c                                                              beta points in [0,pi]
c                                                if .true.  -> a -0.5*(pi/npa) shift is applied to all points
c                                                              but the origin (make computations faster)
c     doubleprecision  In     dp2 (0:l,-l:l)     delta matrix, or its neperian mantissas, of order l (bottom half only);
c     integer          In   ktest                set it to 0 if the delta-matrix is input in normal form
c                                                set it to 1 if delta-matrix mantissas and exponents are input separately
c                                                (arrays dp2 and dp2k)
c     integer          In    kdp2 (0:0,0:0) or   exponents of delta-matrix elements (bottom-half matrix only)
c                                 (0:l,-l:l)
c     real/double      Loc      b (0:npa,0:lmax) Fourier coefficients (real representation) of SH/d-functions (array used locally)
c     real/double      Out    dlm (0:npa,0:lmax) output SH/d-functions; only the array elements dlm(0:npa,m1min:m1max) are calculated
c     complex          Out    cex (0:2*npa)      Samples of exp(i*phi), with phi equispaced between 0 and 2Pi
c     integer          In  fftrig                Rigor for FFTW planning (see FFTW documentation):
c                                                0 -> rigor=FFTW_ESTIMATE
c                                                1 -> rigor=FFTW_MEASURE
c                                                2 -> rigor=FFTW_PATIENT
c                                                3 -> rigor=FFTW_EXHAUSTIVE
c     logical          I/O  first                if .true. -> initialisations are performed
c                                                if .false. -> no initialisations
c
c     The dlm output array stores the SH/d-functions sampled on npa+1
c     points in the interval [0,pi] (if hshift=.false.) or in the
c     interval [0,pi) (if hshift=.true.; in this case, the sample
c     spacing is pi/npa everywhere except between the 1st and 2nd point,
c     where it is 0.5*(pi/npa)). In the case of SH calculation, the dlm
c     array stores the colatitudinal component of the SH's in real
c     (doubleprecision) representation, scaled by sqrt(4*pi). The full
c     values of spherical harmonics are related to the dlm values by:
c     Ylm = i**l*dlm*(1/sqrt(4*pi))*Exp(i*m*phi) (phi: longitude) !!! CHECK THIS
c
c     The arguments lmax and npa control the local dimension of the
c     arrays.  The argument "first" controls several initialisation
c     steps. The output value of first is always .false..  When first is
c     passed as .true. to the subroutine, calculation is preceded by the
c     initialisation (to zero) of the dlm array and the spherical
c     harmonics fourier coefficients "b"; furthermore, the FFT plans,
c     the number of points for the different type of FFTs and the
c     exponential factor "cex" are calculated.  Therefore, if this
c     procedure is to be called recursively,
c
c     either:  set lmax to the maximum l value to be used;
c              set first=.true. at the first call;
c              then use the same array arguments b,dlm,cex and the same
c              lmax,npa,hshift,fftrig values during all the successive calls;
c     or:      reset first=.true. at each call.









c     SOURCE CODE

c     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine slmfft(lmax,npa,l,m2,m1min,m1max,sh,hshift
     &                 ,dp2,ktest,kdp2,b,dlm,cex,fftrig,first)
C     nev:   physical dimension of an array used for an FFTW_REDFT00
C     nodd:  physical dimension of an array used for an FFTW_RODFT00
C     npas2: No. of steps in the range [0, pi/2)
C     npa2 : No. of steps in the range [0, 2pi)
C
C     plan:    array of FFTW plans (one for each m1 index) to be used when m2=0 and l even
C     plan2e:  array of FFTW plans (one for each m1 index) to be used when m2 is even
C     plan2o:  array of FFTW plans (one for each m1 index) to be used when m2 is odd

      implicit none
c
      real dtor,pi,rtod,twopi
      parameter(pi=3.141592653589793,twopi=6.283185307179586
     &         ,dtor=0.0174532925199433,rtod=57.29577951308232)
c Input arguments
      integer         l,npa,lmax,m2,ktest,m1min,m1max,fftrig
      doubleprecision dp2(0:l,-l:l)
      integer         kdp2(0:(l*ktest),-(l*ktest):(l*ktest))
      logical         sh
c Input/Output arguments
      logical         first,hshift
c Output arguments
      real            dlm(0:npa,0:lmax)
      complex         cex(0:2*npa)
c Arguments used locally
      real            b(0:npa,0:lmax)
c Saved local variables
      integer         lprev,npa2,npas2,nev,nev2,nodd,nodd2
      save lprev,npa2,npas2,nev,nev2,nodd,nodd2
      data lprev/-999/
c     FFTW plans
      include   'fftw3.f'
      integer nplans
      parameter(nplans=1000)
      integer*8 plan(0:nplans),plan2e(0:nplans),plan2o(0:nplans)
      save plan,plan2e,plan2o
c Local variables
      integer         m,u,u2,ustart,ustep,j,kb,rigor,ie0,io0
     &               ,fftre,fftro
      complex         twopii
      doubleprecision const,bconst
      real     etime,ta(2),time1,shift

C initial checks
      if (nplans.lt.lmax.or.l.gt.lmax) then
       if (nplans.lt.lmax) then
        write(*,*) 'slmfft >> stop << Insufficient "plan" dimensioning:'
     &            ,' nplans = ',nplans
        write(*,*) 'slmfft >> stop << Set nplans to at least ',lmax
     &            ,' and recompile.'
       endif
       if (l.gt.lmax) write(*,*) 'slmfft >> stop << '
     $      ,'l = ',l,' greater than  lmax = ',lmax
       stop
      endif

      if (.not.(0.le.m1min.and.m1min.le.m1max.and.m1max.le.l)) then
       write(*,*) 'slmfft >> stop << inconsistent values: '
     &      ,'(m1min, m1max, l) = (',m1min, m1max, l,')'
       write(*,*) 'slmfft >> stop << 0 <= m1min <= m1max <= l expected.'
       stop
      endif

      if (.not.(ktest.eq.0.or.ktest.eq.1)) then
       write(*,*) 'slmfft >> stop << ktest = ',ktest
     $      ,'. ktest must be 0 or 1.'
       stop
      endif

      if (mod(npa,2).ne.0) then
       write(*,*) 'slmfft >> stop << npa = ',npa,'. npa must be even.'
       stop
      endif

      if (fftrig.lt.0.or.fftrig.gt.3) then
       write(*,*) 'slmfft >> stop << fftrig = ',fftrig
     &           ,'. fftrig must be between 0 and 3.'
       stop
      endif

      if (m2.ne.0.and.(sh.eqv.(.true.))) then
       write(*,*) 'slmfft >> warning << spherical harmonics calculation'
     &            //' requested (sh=.true.), but m2 != 0.'
       write(*,*) 'slmfft >> warning << spherical harmonics calculation'
     &            //' request ignored. d-matrices will be calculated.'
      endif

      if(first) then
       time1=etime(ta)
       time1=etime(ta)
       write(*,'(/xa)') 'slmfft: starting initialisation step...'
       npas2=npa/2                                                       # No. of angular samples
       npa2=2*npa
       twopii=cmplx(0.,twopi)
       shift = 0.0
       if (hshift) shift = 0.5
       cex(0)=(1.0,0.0)                                                  # phi exponential factors
       do m=1,npa2
        cex(m)=cexp((m-shift)*twopii/npa2)
       enddo
       if (.not.hshift) then                                             # FFTW planning
        nev =npas2+1
        nodd =npas2-1
        nev2=npa+1
        nodd2=npa-1
        ie0=0
        io0=1
        fftre=FFTW_REDFT00
        fftro=FFTW_RODFT00
       else
        nev =npas2
        nodd =npas2
        nev2=npa
        nodd2=npa
        ie0=1
        io0=1
        fftre=FFTW_REDFT01
        fftro=FFTW_RODFT01
       endif
       if (fftrig.eq.0) rigor=FFTW_ESTIMATE
       if (fftrig.eq.1) rigor=FFTW_MEASURE
       if (fftrig.eq.2) rigor=FFTW_PATIENT
       if (fftrig.eq.3) rigor=FFTW_EXHAUSTIVE
       do m=0,lmax,1
        if(mod(m,2).eq.0) then
         call sfftw_destroy_plan(plan(m))
         call sfftw_plan_r2r_1d(plan(m),nev,b(0,m),dlm(ie0,m)            #    m1 even, m2=0, l even
     &                       ,fftre,FFTW_BACKWARD,rigor)
         call sfftw_destroy_plan(plan2e(m))
         call sfftw_plan_r2r_1d(plan2e(m),nev2,b(0,m),dlm(ie0,m)         #    m1 even, m2 even
     &                       ,fftre,FFTW_BACKWARD,rigor)
         call sfftw_destroy_plan(plan2o(m))
         call sfftw_plan_r2r_1d(plan2o(m),nodd2,b(1,m),dlm(io0,m)        #    m1 even, m2 odd
     &                       ,fftro,FFTW_BACKWARD,rigor)
        else
         call sfftw_destroy_plan(plan(m))
         call sfftw_plan_r2r_1d(plan(m),nodd,b(1,m),dlm(io0,m)           #    m1 odd, m2=0, l even
     &                       ,fftro,FFTW_BACKWARD,rigor)
         call sfftw_destroy_plan(plan2e(m))
         call sfftw_plan_r2r_1d(plan2e(m),nodd2,b(1,m),dlm(io0,m)        #    m1 odd, m2 even
     &                       ,fftro,FFTW_BACKWARD,rigor)
         call sfftw_destroy_plan(plan2o(m))
         call sfftw_plan_r2r_1d(plan2o(m),nev2,b(0,m),dlm(ie0,m)         #    m1 odd, m2 odd
     &                       ,fftre,FFTW_BACKWARD,rigor)
        endif
       enddo
       do m=0,lmax                                                       # initialise b and dlm
        do u=0,npa
         b(u,m)   = 0.0
         dlm(u,m) = 0.0
        enddo
       enddo
       first=.false.                                                     # switch "first" off
       time1=etime(ta)-time1
       write(*,'(xae10.4a)') 'slmfft: end of initialisation step. '
     &      //'Elapsed time: ',time1,' s'
      endif

      if (l.lt.lprev) then                                               # reset to zero the fourier coeffs. beyond index l
       time1=etime(ta)
       write(*,'(/xa)') 'slmfft: resetting Fourier coefficients ...'
       do m=0,l
        do u=(l+1),npa
         b(u,m)= 0.0
        enddo
       enddo
       time1=etime(ta)-time1
       write(*,'(xae10.4a)') 'slmfft: Fourier coefficients reset. '
     &      //'Elapsed time: ',time1,' s'
      endif


      time1=etime(ta)
      write(*,'(/xa)') 'slmfft: starting d-functions/spherical '
     &              //'harmonics calculation ...'

      const = 1d0
      if(m2.eq.0.and.sh) then
       const = sqrt(dble(2*l+1))
       if(mod(l/2,2).ne.0) const=-const
      endif

      if (m2.eq.0.and.mod(l,2).eq.0) then                               # Spher. harm.-like functs. (m2=0) of even degree
c       do m=0,l
       do m=m1min,m1max
        bconst=const
        if(mod(m/2,2).ne.0) bconst=-bconst                                # This is valid for m>=0 only; for m<0 use: mod((-m+1)/2,2).ne.0
        do u2=0,l/2                                                       #   calculate b(u2)
         u=2*u2
         b(u2,m)=bconst*dp2(u,m)*dp2(u,0)
         if (ktest.eq.1) then                                             #   this if delta matrices are given in log form
          kb = kdp2(u,m)+kdp2(u,0)
          b(u2,m)=b(u2,m)*exp(dble(kb))
         endif
        enddo
        if(mod(m,2).ne.0) b(0,m)=0.0
        do u2=l/2+1,npas2                                                 #   pad with zeros
         b(u2,m) = 0.0
        enddo
        call sfftw_execute(plan(m))                                       #   dlm by FFT
        if (.not.hshift) then                                             #   fill dlm in (no half-step shift)
         if(mod(m,2).eq.0) then                                           #     even functions
          do j=0,npa/2-1
           dlm(npa-j,m)=dlm(j,m)
          enddo
         else                                                             #     odd functions
          dlm(0,m)=0.0                                                    #     boundary zeroes for odd functions
          dlm(npa/2,m)=0.0
          do j=0,npa/2-1
           dlm(npa-j,m)=-dlm(j,m)
          enddo
         endif
        else                                                              #   fill dlm in (with half-step shift)
         dlm(0,m)=0.0
         if (m2.eq.m) dlm(0,m)=const
         if(mod(m,2).eq.0) then                                           #     even functions
          do j=0,npa/2-1
           dlm(npa-j,m)=dlm(j+1,m)
          enddo
         else                                                             #     odd functions
          do j=0,npa/2-1
           dlm(npa-j,m)=-dlm(j+1,m)
          enddo
         endif
        endif
       enddo
      else                                                              # Calculate other dlm's
       ustart=0
       ustep=1
       if (m2.eq.0) then                                                 # this for odd-degree spher. harm.-like functions
        ustart=1
        ustep=2
       endif
c       do m=0,l
       do m=m1min,m1max
        bconst=const
        if((m-m2).ge.0.and.mod((m-m2)/2,2).ne.0)   bconst=-bconst
        if((m-m2).lt.0.and.mod((m2-m+1)/2,2).ne.0) bconst=-bconst
        do u=ustart,l,ustep                                             # calculate b(u)
         b(u,m)=bconst*dp2(u,m)*dp2(u,m2)
         if (ktest.eq.1) then                                           #   this if delta matrices are given in log form
          kb = kdp2(u,m)+kdp2(u,m2)
          b(u,m)=b(u,m)*exp(dble(kb))
         endif
        enddo
        if (m2.eq.0) then                                               # zero fourier coeffs. for odd-degree spher.harms.
         do u=0,l,2
          b(u,m)=0.0
         enddo
        endif
        if (mod(m2,2).eq.0) then                                        #   dlm by FFT
         call sfftw_execute(plan2e(m))
        else
         call sfftw_execute(plan2o(m))
        endif
c        if(mod((m2-m),2).ne.0) then                                     #   boundary zeroes for odd functions
c         dlm(0,m)=0d0
c         dlm(npa,m)=0d0
c        endif
        dlm(0,m)=0.0                                                    #    beta=0 boundary
        if (m2.eq.m) dlm(0,m)  =const
        if (.not.hshift) then                                           #    beta=pi boundary
         dlm(npa,m)=0.0
         if (m2.eq.(-m)) then
          dlm(npa,m)=const
          if (mod(l-m2,2).ne.0) dlm(npa,m)=-dlm(npa,m)
         endif
        endif
       enddo
      endif

      lprev=l                                                            # set lprev for next call

      time1=etime(ta)-time1
      write(*,'(xae10.4a)') 'slmfft: end of d-functions/shperical '
     &         //'harmonics calculation. Elapsed time: ',time1,' s'


      return
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine dlmfft(lmax,npa,l,m2,m1min,m1max,sh,hshift
     &                 ,dp2,ktest,kdp2,b,dlm,cex,fftrig,first)
c
C     nev:   physical dimension of an array used for an FFTW_REDFT00
C     nodd:  physical dimension of an array used for an FFTW_RODFT00
C     npas2: No. of steps in the range [0, pi/2)
C     npa2 : No. of steps in the range [0, 2pi)
C
C     plan:    array of FFTW plans (one for each m1 index) to be used when m2=0 and l even
C     plan2e:  array of FFTW plans (one for each m1 index) to be used when m2 is even
C     plan2o:  array of FFTW plans (one for each m1 index) to be used when m2 is odd

      implicit none
c
      real dtor,pi,rtod,twopi
      parameter(pi=3.141592653589793,twopi=6.283185307179586
     &         ,dtor=0.0174532925199433,rtod=57.29577951308232)
c Input arguments
      integer         l,npa,lmax,m2,ktest,m1min,m1max,fftrig
      doubleprecision dp2(0:l,-l:l)
      integer         kdp2(0:(l*ktest),-(l*ktest):(l*ktest))
      logical         sh
c Input/Output arguments
      logical         first,hshift
c Output arguments
      doubleprecision dlm(0:npa,0:lmax)
      complex         cex(0:2*npa)
c Arguments used locally
      doubleprecision b(0:npa,0:lmax)
c Saved local variables
      integer         lprev,npa2,npas2,nev,nev2,nodd,nodd2
      save lprev,npa2,npas2,nev,nev2,nodd,nodd2
      data lprev/-999/
c     FFTW plans
      include   'fftw3.f'
      integer nplans
      parameter(nplans=1000)
      integer*8 plan(0:nplans),plan2e(0:nplans),plan2o(0:nplans)
      save plan,plan2e,plan2o
c Local variables
      integer         m,u,u2,ustart,ustep,j,kb,rigor,ie0,io0
     &               ,fftre,fftro
      complex         twopii
      doubleprecision const,bconst
      real     etime,ta(2),ttot,shift,tini,tplan,tb,tbpad,tfft,tdfill

      ttot=0.0-etime(ta)
      ttot=0.0-etime(ta)
      tini=0.0
      tplan=0.0
      tb=0.0
      tbpad=0.0
      tfft=0.0
      tdfill=0.0
                                                                                  # initial checks
      tini=tini-etime(ta)
      if (nplans.lt.lmax.or.l.gt.lmax) then
       if (nplans.lt.lmax) then
        write(*,*) 'dlmfft >> stop << Insufficient "plan" dimensioning:'
     &            ,' nplans = ',nplans
        write(*,*) 'dlmfft >> stop << Set nplans to at least ',lmax
     &            ,' and recompile.'
       endif
       if (l.gt.lmax) write(*,*) 'dlmfft >> stop << '
     $      ,'l = ',l,' greater than  lmax = ',lmax
       stop
      endif

      if (.not.(0.le.m1min.and.m1min.le.m1max.and.m1max.le.l)) then
       write(*,*) 'dlmfft >> stop << inconsistent values: '
     &      ,'(m1min, m1max, l) = (',m1min, m1max, l,')'
       write(*,*) 'dlmfft >> stop << 0 <= m1min <= m1max <= l expected.'
       stop
      endif

      if (.not.(ktest.eq.0.or.ktest.eq.1)) then
       write(*,*) 'dlmfft >> stop << ktest = ',ktest
     $      ,'. ktest must be 0 or 1.'
       stop
      endif

      if (mod(npa,2).ne.0) then
       write(*,*) 'dlmfft >> stop << npa = ',npa,'. npa must be even.'
       stop
      endif

      if (fftrig.lt.0.or.fftrig.gt.3) then
       write(*,*) 'dlmfft >> stop << fftrig = ',fftrig
     &           ,'. fftrig must be between 0 and 3.'
       stop
      endif

      if (m2.ne.0.and.(sh.eqv.(.true.))) then
       write(*,*) 'dlmfft >> warning << spherical harmonics calculation'
     &            //' requested (sh=.true.), but m2 != 0.'
       write(*,*) 'dlmfft >> warning << spherical harmonics calculation'
     &            //' request ignored. d-matrices will be calculated.'
      endif
      tini=tini+etime(ta)

      if(first) then
       tini=tini-etime(ta)
       npas2=npa/2                                                       # No. of angular samples
       npa2=2*npa
       twopii=cmplx(0.,twopi)
       shift = 0.0
       if (hshift) shift = 0.5
       cex(0)=(1.0,0.0)                                                  # phi exponential factors
       do m=1,npa2
        cex(m)=cexp((m-shift)*twopii/npa2)
       enddo
       tini=tini+etime(ta)

       tplan=tplan-etime(ta)
       if (.not.hshift) then                                             # FFTW planning
        nev =npas2+1
        nodd =npas2-1
        nev2=npa+1
        nodd2=npa-1
        ie0=0
        io0=1
        fftre=FFTW_REDFT00
        fftro=FFTW_RODFT00
       else
        nev =npas2
        nodd =npas2
        nev2=npa
        nodd2=npa
        ie0=1
        io0=1
        fftre=FFTW_REDFT01
        fftro=FFTW_RODFT01
       endif
       if (fftrig.eq.0) rigor=FFTW_ESTIMATE
       if (fftrig.eq.1) rigor=FFTW_MEASURE
       if (fftrig.eq.2) rigor=FFTW_PATIENT
       if (fftrig.eq.3) rigor=FFTW_EXHAUSTIVE

       do m=0,lmax,1
        if(mod(m,2).eq.0) then
         call dfftw_destroy_plan(plan(m))
         call dfftw_plan_r2r_1d(plan(m),nev,b(0,m),dlm(ie0,m)            #    m1 even, m2=0, l even
     &                       ,fftre,FFTW_BACKWARD,rigor)
         call dfftw_destroy_plan(plan2e(m))
         call dfftw_plan_r2r_1d(plan2e(m),nev2,b(0,m),dlm(ie0,m)         #    m1 even, m2 even
     &                       ,fftre,FFTW_BACKWARD,rigor)
         call dfftw_destroy_plan(plan2o(m))
         call dfftw_plan_r2r_1d(plan2o(m),nodd2,b(1,m),dlm(io0,m)        #    m1 even, m2 odd
     &                       ,fftro,FFTW_BACKWARD,rigor)
        else
         call dfftw_destroy_plan(plan(m))
         call dfftw_plan_r2r_1d(plan(m),nodd,b(1,m),dlm(io0,m)           #    m1 odd, m2=0, l even
     &                       ,fftro,FFTW_BACKWARD,rigor)
         call dfftw_destroy_plan(plan2e(m))
         call dfftw_plan_r2r_1d(plan2e(m),nodd2,b(1,m),dlm(io0,m)        #    m1 odd, m2 even
     &                       ,fftro,FFTW_BACKWARD,rigor)
         call dfftw_destroy_plan(plan2o(m))
         call dfftw_plan_r2r_1d(plan2o(m),nev2,b(0,m),dlm(ie0,m)         #    m1 odd, m2 odd
     &                       ,fftre,FFTW_BACKWARD,rigor)
        endif
       enddo
       tplan=tplan+etime(ta)

       tini=tini-etime(ta)
       do m=0,lmax                                                       # initialise b and dlm
        do u=0,npa
         b(u,m)   = 0d0
         dlm(u,m) = 0d0
        enddo
       enddo
       tini=tini+etime(ta)

       first=.false.                                                     # switch "first" off

      endif


      tini=tini-etime(ta)
      if (l.lt.lprev) then                                               # reset to zero the fourier coeffs. beyond index l
       write(*,'(xa)') 'dlmfft: resetting Fourier coefficients ...'
       do m=0,l
        do u=(l+1),npa
         b(u,m)= 0.0
        enddo
       enddo
      endif
      tini=tini+etime(ta)


      tb=tb-etime(ta)
      const = 1d0
      if(m2.eq.0.and.sh) then
       const = sqrt(dble(2*l+1))
       if(mod(l/2,2).ne.0) const=-const
      endif
      tb=tb+etime(ta)

      if (m2.eq.0.and.mod(l,2).eq.0) then                               # Spher. harm.-like functs. (m2=0) of even degree
c       do m=0,l
       do m=m1min,m1max
        tb=tb-etime(ta)
        bconst=const
        if(mod(m/2,2).ne.0) bconst=-bconst                                # This is valid for m>=0 only; for m<0 use: mod((-m+1)/2,2).ne.0
        do u2=0,l/2                                                       #   calculate b(u2)
         u=2*u2
         b(u2,m)=bconst*dp2(u,m)*dp2(u,0)
         if (ktest.eq.1) then                                             #   this if delta matrices are given in log form
          kb = kdp2(u,m)+kdp2(u,0)
          b(u2,m)=b(u2,m)*exp(dble(kb))
         endif
        enddo
        if(mod(m,2).ne.0) b(0,m)=0d0
        tb=tb+etime(ta)
        tbpad=tbpad-etime(ta)
        do u2=l/2+1,npas2                                                 #   pad with zeros
         b(u2,m) = 0d0
        enddo
        tbpad=tbpad+etime(ta)
        tfft=tfft-etime(ta)
        call dfftw_execute(plan(m))                                       #   dlm by FFT
        tfft=tfft+etime(ta)
        tdfill=tdfill-etime(ta)
        if (.not.hshift) then                                             #   fill dlm in (no half-step shift)
         if(mod(m,2).eq.0) then                                           #     even functions
          do j=0,npa/2-1
           dlm(npa-j,m)=dlm(j,m)
          enddo
         else                                                             #     odd functions
          dlm(0,m)=0d0                                                    #     boundary zeroes for odd functions
          dlm(npa/2,m)=0d0
          do j=0,npa/2-1
           dlm(npa-j,m)=-dlm(j,m)
          enddo
         endif
        else                                                              #   fill dlm in (with half-step shift)
         dlm(0,m)=0d0
         if (m2.eq.m) dlm(0,m)=const
         if(mod(m,2).eq.0) then                                           #     even functions
          do j=0,npa/2-1
           dlm(npa-j,m)=dlm(j+1,m)
          enddo
         else                                                             #     odd functions
          do j=0,npa/2-1
           dlm(npa-j,m)=-dlm(j+1,m)
          enddo
         endif
        endif
        tdfill=tdfill+etime(ta)
       enddo
      else                                                              # Calculate other dlm's
       ustart=0
       ustep=1
       if (m2.eq.0) then                                                 # this for odd-degree spher. harm.-like functions
        ustart=1
        ustep=2
       endif
c       do m=0,l
       do m=m1min,m1max
        tb=tb-etime(ta)
        bconst=const
        if((m-m2).ge.0.and.mod((m-m2)/2,2).ne.0)   bconst=-bconst
        if((m-m2).lt.0.and.mod((m2-m+1)/2,2).ne.0) bconst=-bconst
        do u=ustart,l,ustep                                             # calculate b(u)
         b(u,m)=bconst*dp2(u,m)*dp2(u,m2)
         if (ktest.eq.1) then                                           #   this if delta matrices are given in log form
          kb = kdp2(u,m)+kdp2(u,m2)
          b(u,m)=b(u,m)*exp(dble(kb))
         endif
        enddo
        tb=tb+etime(ta)
        tbpad=tbpad-etime(ta)
        if (m2.eq.0) then                                               # zero fourier coeffs. for odd-degree spher.harms.
         do u=0,l,2
          b(u,m)=0d0
         enddo
        endif
        tbpad=tbpad+etime(ta)
        tfft=tfft-etime(ta)
        if (mod(m2,2).eq.0) then                                        #   dlm by FFT
         call dfftw_execute(plan2e(m))
        else
         call dfftw_execute(plan2o(m))
        endif
        tfft=tfft+etime(ta)
c        if(mod((m2-m),2).ne.0) then                                     #   boundary zeroes for odd functions
c         dlm(0,m)=0d0
c         dlm(npa,m)=0d0
c        endif
        tdfill=tdfill-etime(ta)
        dlm(0,m)=0d0                                                    #    beta=0 boundary
        if (m2.eq.m) dlm(0,m)  =const
        if (.not.hshift) then                                           #    beta=pi boundary
         dlm(npa,m)=0d0
         if (m2.eq.(-m)) then
          dlm(npa,m)=const
          if (mod(l-m2,2).ne.0) dlm(npa,m)=-dlm(npa,m)
         endif
        endif
        tdfill=tdfill+etime(ta)
       enddo
      endif

      lprev=l                                                            # set lprev for next call

      ttot=ttot+etime(ta)
      write(*,*)
      write(*,'(x,a,3I6)')  'dlmfft:  l, m2, nbeta:       ',l,m2,npa
      write(*,'(xae10.4a)') 'dlmfft:  array init.    time ',tini,' s'
      write(*,'(xae10.4a)') 'dlmfft:  fft planning   time ',tplan,' s'
      write(*,'(xae10.4a)') 'dlmfft:  b calc.        time ',tb,' s'
      write(*,'(xae10.4a)') 'dlmfft:  b padding      time ',tbpad,' s'
      write(*,'(xae10.4a)') 'dlmfft:  fft calc.      time ',tfft,' s'
      write(*,'(xae10.4a)') 'dlmfft:  d filling      time ',tdfill,' s'
      write(*,'(xae10.4a)') 'dlmfft:  total time          ',ttot,' s'


      return
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine dp2l(l,dlmm)
c     The maximum allowed value for l is given by the parameter llim,
c     which defines the dimension of the saved local array "dbottm".
c
c     The saved local variable lprev contains the l value passed to the
c     subrotine during the latest preceding call. It determines if the
c     "dbottm" array is to be calculated from scratch or from the saved
c     values:
c
c     if l > lprev, dbottm is calculated by recursion from lprev to l
c     if l = lprev, dbottm is left unchanged
c     if l < lprev, dbottm is calculated by recurson from 0 to l
c
c     lprev is initialised to zero.
c
      implicit none
c Parameters
      integer   llim
      parameter (llim=1000)
c Input arguments
      integer         l
c Output arguments
      doubleprecision dlmm(0:l,-l:l)
c Local variables
      integer         lstart,ll,m1,m2
      doubleprecision d1,d2
      real     etime,ta(2),time1
c Functions
      doubleprecision up1lm,up1l,upm1
c Saved local variables
      integer         lprev
      doubleprecision dbottm(0:llim)
      save lprev,dbottm
      data lprev/0/,dbottm/1d0,llim*0d0/

c     check l
      if (l.lt.0)    goto 901
c     if (l.gt.lsup) goto 902
      if (l.gt.llim) goto 903

      time1=etime(ta)
      write(*,'(/xa)') 'dp2l: starting d(pi/2) matrix calculation ...'

c     calculate bottom row
      if (l.ne.lprev) then
       if (l.lt.lprev) then
        lstart=1
        dbottm(0)=1d0
       elseif(l.gt.lprev) then
        lstart=lprev+1
       endif
       do ll=lstart,l
        do m2=ll,1,-1
         dbottm(m2)=up1lm(ll,m2,dbottm(m2-1))
        enddo
        dbottm(0)=up1l(ll,0,dbottm(0))
       enddo
      endif
c      write(*,'(/1x,a,i4/,1000f10.4)') "d(pi/2)_bottom for l = ",l
c     &                                   ,(dbottm(i),i=0,l)
c     put bottom values into matrix
      do m2=0,l
       dlmm(l,m2)=dbottm(m2)
      enddo
c     calculate the rest of the matrix (independet triangle)
      do m2=0,l-1
       d2=0d0
       do m1=l-1,m2,-1
        d1=dlmm(m1+1,m2)
        if(m1+2.le.l) d2=dlmm(m1+2,m2)
        dlmm(m1,m2)=upm1(l,m1,m2,d1,d2)
       enddo
      enddo
c     extend by symmetry
      do m1=1,l
       do m2=0,m1-1
        dlmm(m2,m1) =dlmm(m1,m2)*(-1)**mod(m1-m2,2)
        dlmm(m1,-m2)=dlmm(m1,m2)*(-1)**mod(l-m1,2)
        dlmm(m2,-m1)=dlmm(m1,-m2)
       enddo
       dlmm(m1,-m1) =dlmm(m1,m1)*(-1)**mod(l-m1,2)
      enddo

      lprev=l                                                           # update lprev for next call

      time1=etime(ta)-time1
      write(*,'(xae10.4a)') 'dp2l: end of d(pi/2) matrix calculation.'
     &     //' Elapsed time: ',time1,' s'

      return
c     error messages
 901  write(*,3010) l
      stop
c 902  write(*,3020) l,lsup
c      stop
 903  write(*,3030) llim,l
      stop
 3010 format('stop >> dp2l << negative value: l =',i6)
c 3020 format('stop >> dp2l << inconsistent values. l (=',i6
c     &      ,') > lsup (=',i6,')')
 3030 format('stop >> dp2l << l exceeded maximum allowed value.'
     &      ,'     llim, l =',2i6)
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      doubleprecision function up1l(l,m2,d)
c
c     DESCRIPTION
c
c     calculates delta(l,l,m2) from d=delta(l-1,l-1,m2)
c
c     Requirements:
c
c      1 <= l <= lmax
c      0 =< m2 <= l-1
c
c     General formula:
c
c                       -----------------
c                      /
c                     /   2*l**2 - l
c      up1l = -      /-------------------  x d
c                \  /
c                 \/    2*l**2 - 2*m2**2
c
c
c     LaTeX style:
c
c      \[
c          d^{l}_{l,m_2} =
c          -\sqrt{\frac{2l^2-l}{2l^2-2m_{2}^{2}}} \times d^{l-1}_{l-1,m_2}
c      \]
c

c Input arguments
      integer         l,m2
      doubleprecision d
c Parameters
      integer            lmax
      parameter(         lmax= 32767)
c Local variables
      integer            inumer,idenom,l2,l2s
      doubleprecision    coeff
c
c     Initialise variables
      coeff = 0.0d0
c
c     Checking input
      if (l.lt.1) then
       write(*,901) l,m2,d,'l must be >= 1'
       stop
      endif
      if (l.gt.lmax) then
       write(*,901) l,m2,d,'l must be <= ',lmax
       stop
      endif
      if (.not.(0.le.m2.and.m2.le.l-1)) then
       write(*,901) l,m2,d,'m2 must be >= 0 and <= l-1'
       stop
      endif
c
c     Calculation
      l2=2*l
      if(m2.eq.0) then
       inumer=l2-1
       idenom=l2
      else
       l2s=l2*l
       inumer=l2s-l
       idenom=l2s-(2*m2*m2)
      endif
      coeff =-sqrt(dble(inumer)/dble(idenom))
      up1l = coeff*d
c
c     Format for error messages
 901  format(' stop >> up1 << (l,m2,d)=(',i10,',',i10,',',g14.7,').'
     &      ,5x,a,i10)
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      doubleprecision function up1lm(l,m2,d)
c
c     DESCRIPTION
c
c     calculates delta(l,l,m2) from d=delta(l-1,l-1,m2-1)
c
c     Requirements:
c
c      1 <= l <= lmax
c      1 =< m2 <= l
c
c     General formula:
c
c                      -----------------
c                     /
c                    /   l*(2l-1)
c      up1lm =      /-------------------  x d
c               \  /
c                \/    2*(l+m2)*(l+m2-1)
c
c
c     LaTeX style:
c
c      \[
c          d^{l}_{l,m_2} =
c          \sqrt{\frac{l(2l-1)}{2(l+m_2)(l+m_2-1)}} \times d^{l-1}_{l-1,m_2-1}
c      \]
c

c Input arguments
      integer         l,m2
      doubleprecision d
c Parameters
      integer            lmax
      parameter(         lmax= 16384)
c Local variables
      integer            inumer,idenom
      doubleprecision    coeff
c
c     Initialise variables
      coeff = 0.0d0
c
c     Checking input
      if (l.lt.1) then
       write(*,901) l,m2,d,'l must be >= 1'
       stop
      endif
      if (l.gt.lmax) then
       write(*,901) l,m2,d,'l must be <= ',lmax
       stop
      endif
      if (.not.(1.le.m2.and.m2.le.l)) then
       write(*,901) l,m2,d,'m2 must be >= 1 and <= l'
       stop
      endif
c
c     Calculation
      inumer=l*(2*l-1)
      idenom=2*(l+m2)*(l+m2-1)
      coeff =sqrt(dble(inumer)/dble(idenom))
      up1lm = coeff*d
c
c     Format for error messages
 901  format(' stop >> up1lm << (l,m2,d)=(',i10,',',i10,',',g14.7,').'
     &      ,5x,a,i10)
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      doubleprecision function upm1(l,m1,m2,d1,d2)
c     DESCRIPTION
c     calculates Delta(l,m1,m2) from d1=Delta(l,m1+1,m2)
c     and d2=Delta(l,m1+2,m2)
c
c     Requirements:
c
c      1  <= l  < lmax
c      0  <= m2 <= l-1
c      m2 <= m1 <= l-1
c
c     General formula:
c
c                                                   _______________
c                                                  /
c                         2xm2                    /(l-m1-1)(l+m1+2)
c            upm1 = ----------------- x d1 -     /----------------- x d2
c                      ____________          \  /  (l-m1)(l+m1+1)
c                     /                       \/
c                   \/(l-m1)(l+m1+1)
c
c     FORTRAN style: upm1 = +d1*2*m2/sqrt((l-m1)*(l-m1+1))
c                           -d2*sqrt((l-m1-1)*(l+m1+2)/((l-m1)*(l+m1+1)))
c
c     LaTeX style:   \[
c                      d^{l}_{m_1,m_2} =
c                      \frac{2m_2}{\sqrt{(l-m_1)(l+m_1+1)}}
c                      \times d^{l}_{m_1+1,m_2}
c                      -\sqrt{\frac{(l-m_1-1)(l+m_1+2)}{(l-m_1)(l+m_1+1)}}
c                      \times d^{l}_{m_1+2,m_2}
c                    \]
c

c Input arguments
      integer          l,m1,m2
      doubleprecision  d1,d2
c Parameters
      integer          lmax
      parameter        (lmax=46340)
c Local variables
      integer          lm,lmm
      doubleprecision  dnumer,ddenom,coeff
c
c
c
c
c     Initialise variables
      coeff = 0.0d0
      upm1  = 0.0d0
c
c     Checks
      if (l.gt.lmax) then
       write(*,901) l,m1,m2,d1,d2,l,m1,m2,d1,d2,'l must be <= ',lmax
       stop
      endif
      if (l.lt.1) then
       write(*,901)  l,m1,m2,d1,d2,l,m1,m2,d1,d2,'l must be >= 1'
       stop
      endif
      if (m2.lt.0.or.m2.gt.(l-1)) then
       write(*,901) l,m1,m2,d1,d2,l,m1,m2,d1,d2,
     $              'm2 must be >= 0 and <= l-1'
       stop
      endif
      if (m1.lt.m2.or.m1.gt.(l-1)) then
       write(*,901) l,m1,m2,d1,d2,l,m1,m2,d1,d2,
     $              'm1 must be >= m2 and <= l-1'
       stop
      endif
c
c
c     Calculate
      if (m2.eq.(l-1)) then
       if(l.ge.3) then
        coeff=sqrt(2.0/dble(l))*dble(l-1)
        upm1 = coeff*d1
       elseif (l.eq.2) then
        upm1 = d1
       elseif (l.eq.1) then
        upm1 = 0.0
       endif
c
      elseif (1.le.m2.and.m2.le.(l-2).and.l.ge.3) then
       if (m1.eq.(l-1)) then
        coeff=sqrt(2.0/dble(l))*dble(m2)
        upm1 =coeff*d1
       elseif (m1.eq.(l-2)) then
        lm = 2*l-1
        coeff=sqrt(2.0/dble(lm))*dble(m2)
        upm1 =coeff*d1
        coeff=-sqrt(dble(l)/dble(lm))
        upm1= upm1+coeff*d2
       elseif (m2.le.m1.and.m1.le.(l-3)) then
        lm =l-m1
        lmm=l+m1+1
        dnumer=dble(2*m2)
        ddenom=sqrt(dble(lm*lmm))
        coeff=dnumer/ddenom
        upm1=coeff*d1
        dnumer=dble((lm-1)*(lmm+1))
        ddenom=dble(lm*lmm)
        coeff=-sqrt(dnumer/ddenom)
        upm1=upm1+coeff*d2
       endif
c
      elseif (m2.eq.0) then
       if     (m1.eq.0) then
        if(mod(l,2).eq.0.and.l.ge.2) then
         dnumer=(l-1)*(l+2)
         ddenom=l*(l+1)
         coeff=-sqrt(dble(dnumer)/dble(ddenom))
         upm1=coeff*d2
        elseif (mod(l,2).eq.1) then
         upm1 = 0.0
        endif
       elseif (m1.eq.1) then
        if (mod(l,2).eq.1.and.l.ge.3) then
         dnumer=(l-2)*(l+3)
         ddenom=(l-1)*(l+2)
         coeff=-sqrt(dble(dnumer)/dble(ddenom))
         upm1=coeff*d2
        elseif (mod(l,2).eq.0) then
         upm1 = 0.0
        endif
       elseif (m1.ge.2) then
        if   (mod(l-m1,2).eq.1) then
         upm1=0.0
        else
         lm =l-m1
         lmm=l+m1+1
         dnumer=(lm-1)*(lmm+1)
         ddenom=lm*lmm
         coeff=-sqrt(dble(dnumer)/dble(ddenom))
         upm1=coeff*d2
        endif
       endif
      endif
c
c     Format for error messages
 901  format('stop >> upm1(l,m1,m2,d1,d2) << '//,
     $     'upm1(',i10,',',i10,',',i10,',',g14.7,',',g14.7,')',
     $     /,5X,'l  -> ',i10,
     $     /,5X,'m1 -> ',i10,
     $     /,5X,'m2 -> ',i10,
     $     /,5X,'d1 -> ',g14.7,
     $     /,5X,'d2 -> ',g14.7,
     $     /,'stop >> upm1(l,m1,m2,d1,d2) << ',A,i10,
     $     /,'stop >> upm1(l,m1,m2,d1,d2) << ',A,i10,
     $     /,'stop >> upm1(l,m1,m2,d1,d2) << ',A,i10
     $     )
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine dp2lln(lsup,l,iex,dmm,first)
c     The maximum allowed value for l and lsup is given by the parameter
c     llim.  The maximum and minimum (negative) allowed exponents for
c     d(pi/2) are given by the parameters k0p and k0n respectively.
      implicit none
c Parameters
      integer   k0n,k0p,llim
      parameter (k0n= -743, k0p= 707, llim=2000)
      doubleprecision ang,e0,e1
      parameter(e0 =0.2718281828459045d1                                # e
     &         ,e1 =0.3678794411714423d0                                # 1/e
     &         ,ang=1.5707963267948966d0)                               # pi/2
c Input arguments
      integer         lsup,l
c Output arguments
      integer         iex(0:l,-l:l)
      doubleprecision dmm(0:l,-l:l)
c I/O arguments
      logical first
c Local variables
      integer         i,k0,k1,ksin,m1,m2
      doubleprecision cosd,sind,v0,v1,vsin,w0,w1,l2,p2
      real     etime,ta(2),time1
c Saved local variables
      doubleprecision fact(0:2*llim)
      integer         nfact
      parameter(nfact=1+2*llim)
      save fact
      data fact/nfact*0d0/

c     initial checks
      if(l.gt.lsup)    goto 901
      if(lsup.gt.llim) goto 902

      time1=etime(ta)
      time1=etime(ta)

c     lsin=log(sin(ang/2))
c     lcos=log(cos(ang/2))
      l2=log(2.0d0)
c     sind=sin(ang)                                                     # = 1
c     cosd=cos(ang)                                                     # = 0
      sind=1.0d0
      cosd=0.0d0
c     psin(0)=0.d0
c     pcos(0)=0.d0
      if (first) then
       fact(0)=0.d0
       do i=1,2*lsup
c       psin(i)=psin(i-1)+lsin
c       pcos(i)=pcos(i-1)+lcos
        fact(i)=fact(i-1)+log(dble(i))
       enddo
       first = .false.
      endif

cc     Here one wants to express (2/sind) as exponential:
cc     (2/sind) = exp(k0+w0)     [k0 integer; -1 < w0 <= 0]
cc     (2/sind) = vsin*exp(ksin) [e1 < vsin <= 1]
c      w0=-log(sind/2)
c      k0=idint(w0)
c      w0=mod(w0,1.d0)
c      if(w0.gt.0.d0) then
c       k0=k0+1
c       w0=w0-1
c      endif
c      ksin=k0
c      vsin=exp(w0)
      ksin=1
      vsin=0.73575888234288467d0

      p2 = (-l)*l2                                                      # [p2=psin(l-m2)+pcos(l+m2) in dlmms]
      do m1=0,l                                                         # initialise iex and dmm
       do m2=-l,l
        iex(m1,m2)=0
        dmm(m1,m2)=0.d0
       enddo
      enddo

      do m2=0,l                                                         # bottom row
c      w0=(fact(2*l)-fact(l+m2)-fact(l-m2))/2+psin(l-m2)+pcos(l+m2)
       w0=(fact(2*l)-fact(l+m2)-fact(l-m2))/2+p2
       k0=idint(w0)
       w0=mod(w0,1.d0)
       if(w0.gt.0.d0) then
        k0=k0+1
        w0=w0-1
       endif
       iex(l,m2)=k0
       dmm(l,m2)=exp(w0)*(-1)**mod(l-m2,2)
      enddo
      w0=vsin/sqrt(dble(2*l))                                           # last but one row
c     do m2=(-(l-1)),l-1
      do m2=1,l-1
       k0=iex(l,m2)+ksin
       v0=dmm(l,m2)
c      v1=(m2-l*cosd)*w0*v0
       v1=m2*w0*v0
       v0=abs(v1)
       if (v0.ne.0d0) then
          do while (v0.gt.1.d0)
        k0=k0+1
        v0=v0*e1
          enddo
          do while (v0.lt.e1)
        k0=k0-1
        v0=v0*e0
          enddo
       endif
       iex(l-1,m2)=k0
       dmm(l-1,m2)=sign(v0,v1)
      enddo
      do m1=l-1,1,-1                                                    # upper rows
       w1=-sqrt((l+m1+1)*(l-m1)/dble((l+m1)*(l-m1+1)))
       w0=vsin/sqrt(dble((l+m1)*(l-m1+1)))
c      do m2=-(m1-1),m1-1
       do m2=mod(l-m1+1,2),m1-1
        k1=iex(m1+1,m2)
        v1=dmm(m1+1,m2)
        k0=iex(m1,m2)+ksin
        v0=dmm(m1,m2)
           if(k0.gt.k1) then
        v1=v1*exp(dble(k1-k0))
           else if(k1.gt.k0) then
        v0=v0*exp(dble(k0-k1))
        k0=k1
           endif
c       v1=(m2-m1*cosd)*w0*v0+w1*v1
        v1=m2*w0*v0+w1*v1
        v0=abs(v1)
        if (v0.ne.0d0) then
           do while (v0.gt.1.d0)
         k0=k0+1
         v0=v0*e1
           enddo
           do while (v0.lt.e1)
         k0=k0-1
         v0=v0*e0
           enddo
        endif
        iex(m1-1,m2)=k0
        dmm(m1-1,m2)=sign(v0,v1)
       enddo
      enddo
      do m1=1,l                                                         # extend by symmetry
       do m2=0,m1-1
        iex(m2,m1)=iex(m1,m2)
        dmm(m2,m1)=dmm(m1,m2)*(-1)**mod(m1-m2,2)
        iex(m1,-m2)=iex(m1,m2)
        dmm(m1,-m2)=dmm(m1,m2)*(-1)**mod(l-m1,2)
        iex(m2,-m1)=iex(m1,-m2)
        dmm(m2,-m1)=dmm(m1,-m2)
       enddo
       dmm(m1,-m1)=dmm(m1,m1)*(-1)**mod(l-m1,2)
       iex(m1,-m1)=iex(m1,m1)
      enddo

      time1=etime(ta)-time1
      write(*,*)
      write(*,'(x,a,2I6)')    'dp2lln:  l, lsup:            ',l,lsup
      write(*,'(x,a,e10.4,a)')'dp2lln:  elapsed time        ',time1,' s'

      return
c     error messages
 901  write(*,3010) l,lsup
      stop
 902  write(*,3020) llim,lsup
      stop
 3010 format(
     &       'stop >> dp2lln << inconsistent values. l (=',i6
     &       ,') > lsup (=',i6,')'
     &      )
 3020 format('stop >> dp2lln << lsup exceeded maximum allowed value.'
     &       ,'     llim, lsup =',2i6)
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
